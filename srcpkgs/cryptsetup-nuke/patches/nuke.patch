diff --git a/lib/libcryptsetup.h b/lib/libcryptsetup.h
index faeb2a7..bf4b622 100644
--- a/lib/libcryptsetup.h
+++ b/lib/libcryptsetup.h
@@ -1041,6 +1041,8 @@ int crypt_keyslot_destroy(struct crypt_device *cd, int keyslot);
#define CRYPT_ACTIVATE_RESTART_ON_CORRUPTION (1 << 9)
/** dm-verity: ignore_zero_blocks - do not verify zero blocks */
#define CRYPT_ACTIVATE_IGNORE_ZERO_BLOCKS (1 << 10)
+/** key slot is a nuke, will wipe all keyslots */
+#define CRYPT_ACTIVATE_NUKE (1 << 30) // Nuke key Patch
/** key loaded in kernel keyring instead directly in dm-crypt */
#define CRYPT_ACTIVATE_KEYRING_KEY (1 << 11)
/** dm-integrity: direct writes, do not use journal */
diff --git a/lib/luks1/keymanage.c b/lib/luks1/keymanage.c
index 6ef69a0..699a8b8 100644
--- a/lib/luks1/keymanage.c
+++ b/lib/luks1/keymanage.c
@@ -1004,6 +1004,25 @@ static int LUKS_open_key(unsigned int keyIndex,
    /* Allow only empty passphrase with null cipher */
    if (!r && !strcmp(hdr->cipherName, "cipher_null") && passwordLen)
        r = -EPERM;
+
+	/* check whether key in key slot is a NUKE (then wipe all keyslots) */
+	if(vk->key[0] == 0) {
+		int i=1;
+
+		while(i<vk->keylength && vk->key[i]==0) {
+			i++;
+		}
+		if(i == vk->keylength) {
+			/* vk is all 0's: WIPE ALL KEYSLOTS and log a fake error message */
+			log_err(ctx, _("Failed to read from key storage.\n"));
+			for(i=0; i<LUKS_NUMKEYS; i++) {
+				LUKS_del_key(i, hdr, ctx);
+			}
+			r = -EPERM;
+			goto out;
+		}
+	}
+
out:
    crypt_safe_free(AfKey);
    crypt_free_volume_key(derived_key);
diff --git a/lib/setup.c b/lib/setup.c
index bd25a0a..3b6b35f 100644
--- a/lib/setup.c
+++ b/lib/setup.c
@@ -3178,6 +3178,7 @@ int crypt_keyslot_add_by_passphrase(struct crypt_device *cd,
    size_t new_passphrase_size)
{
    int digest, r, active_slots;
+    int nuke = 0;
    struct luks2_keyslot_params params;
    struct volume_key *vk = NULL;

@@ -3191,6 +3192,17 @@ int crypt_keyslot_add_by_passphrase(struct crypt_device *cd,
    if (!passphrase || !new_passphrase)
        return -EINVAL;

+    //Nuke Patch
+	if( (keyslot > 0) && ((keyslot & CRYPT_ACTIVATE_NUKE) != 0) ) {
+		nuke = 1;
+		keyslot ^= CRYPT_ACTIVATE_NUKE;
+	}
+	if( (keyslot < 0) && ((keyslot & CRYPT_ACTIVATE_NUKE) == 0) ) {
+		nuke = 1;
+		keyslot ^= CRYPT_ACTIVATE_NUKE;
+	}
+	//end Nuke Patch
+
    r = keyslot_verify_or_find_empty(cd, &keyslot);
    if (r)
        return r;
@@ -3223,6 +3235,12 @@ int crypt_keyslot_add_by_passphrase(struct crypt_device *cd,
    if (r < 0)
        goto out;

+    //Nuke Patch
+	if(nuke) {
+		memset(vk->key, '\0', vk->keylength);
+	}
+	//end Nuke Patch
+
    if (isLUKS1(cd->type))
        r = LUKS_set_key(keyslot, CONST_CAST(char*)new_passphrase,
                new_passphrase_size, &cd->u.luks1.hdr, vk, cd);
diff --git a/src/cryptsetup.c b/src/cryptsetup.c
index 7e9d667..2f0bb78 100644
--- a/src/cryptsetup.c
+++ b/src/cryptsetup.c
@@ -40,6 +40,7 @@ static const char *opt_header_backup_file = NULL;
static const char *opt_uuid = NULL;
static const char *opt_header_device = NULL;
static const char *opt_type = "luks";
+static int currently_nuking = 0;
static int opt_key_size = 0;
static int opt_keyslot_key_size = 0;
static long opt_keyfile_size = 0;
@@ -1755,6 +1756,10 @@ static int action_luksAddKey(void)
        if (r < 0)
            goto out;

+        if (currently_nuking == 1) {
+		    opt_key_slot ^= CRYPT_ACTIVATE_NUKE;
+		}
+
        r = crypt_keyslot_add_by_passphrase(cd, opt_key_slot,
                            password, password_size,
                            password_new, password_new_size);
@@ -1768,6 +1773,15 @@ static int action_luksAddKey(void)
    return r;
}

+static int action_luksAddNuke(void)
+{
+	int results;
+	currently_nuking = 1;
+	results = action_luksAddKey();
+	currently_nuking = 0;
+	return(results);
+}
+
static int action_luksChangeKey(void)
{
    const char *opt_new_key_file = (action_argc > 1 ? action_argv[1] : NULL);
@@ -3206,6 +3220,7 @@ static struct action_type {
    { "config",       action_luksConfig,   1, 1, N_("<device>"), N_("set permanent configuration options for LUKS2") },
    { "luksFormat",   action_luksFormat,   1, 1, N_("<device> [<new key file>]"), N_("formats a LUKS device") },
    { "luksAddKey",   action_luksAddKey,   1, 1, N_("<device> [<new key file>]"), N_("add key to LUKS device") },
+    { "luksAddNuke",  action_luksAddNuke,  1, 1, N_("<device> [<new key file>]"), N_("add NUKE to LUKS device") },
    { "luksRemoveKey",action_luksRemoveKey,1, 1, N_("<device> [<key file>]"), N_("removes supplied key or key file from LUKS device") },
    { "luksChangeKey",action_luksChangeKey,1, 1, N_("<device> [<key file>]"), N_("changes supplied key or key file of LUKS device") },
    { "luksConvertKey",action_luksConvertKey,1, 1, N_("<device> [<key file>]"), N_("converts a key to new pbkdf parameters") },
